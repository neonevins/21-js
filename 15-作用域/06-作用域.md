# 第六章 作用域(scope)性质

什么是作用域：

​	通常情况下有人说："天王盖地虎！"有人就会回”宝塔镇河妖“。但是在某些地方会回:"提莫一米五"。这就是不同**场景**下对话环境的不同表意。所以讨论变量讨论值的时候都会有一个前提：在什么环境下，也就是在什么作用域下这个变量的值是多少的问题。

## 1. 全局作用域

什么是全局作用域：

​	一个页面就是一个完整的执行环境，里面就存在唯一的一个作用域,就是全局作用域，

​	全局作用域的本质是全局对象对的属性，

​	在浏览器中全局对象是window，我们申明的变量都相当于在全局对象window下添加属性，或者方法

```js
var a = 2;
console.log(a === window.a);//true 没错，直接添加到window对象下成了其属性
```

​	函数就相当于为全局对象添加方法。

​	在任何地方都可以访问全局作用域下的变量

```js
var a = "a是全局变量";
function foo1(){
    var a = "foo1里面的a"
    console.log(a);
}
function foo2(){
    var a = "foo2里面的a";
    foo1();
}
foo2();//"a是全局变量"
```

函数的变量的作用域是在函数声明时确定的。此时有一个全局作用域，里面有一个a("a是全局变量"),全局作用域里面有一个foo1函数的作用域，里面有一个作用foo1

## 2. 函数作用域

除了全局作用域，还有函数作用域，里面的所有函数只有在函数作用域内才可以调用，外部不能访问内部函数作用域的变量。

```js
let a2 = "这是foo外";
function foo(){
    let a1 = "这是foo内";
    console.log(a1,a2);
}
foo();//"这是foo内" "这是foo外"
console.log(a1,a2);//"报错" "这是foo外"
```

在函数内部可以同时访问a1,a2但是在函数外部只能访问a2,a1不能访问

在函数中传入参数相当于申明了一个局部变量，在调用的过程中赋值

```js
let num = 2;
function foo(num){
	num+=2;
}
foo(4);
console.log(num);//2，没有发生变化
```

不同作用域的变量没有关系！

## 3. 块作用域

除了函数可以生成一个函数作用域之外，代码块也可以生成一个块级作用域

```js
{
    let a = 1;
    console.log(a);//1
}
console.log(a);//a is not defined
```

在代码块里面的a是可以直接访问的，但是在在代码块外面是不可以被访问的。

但是如果你把let改成var之后会是什么情况呢？



## 4. IIFE(立即执行的匿名函数表达式)

函数申明的时候要么是立即执行要么是写上函数名，在合适的位置调用。

```js
function(){console.log("匿名函数错误执行方法")}()//此时会报错: 
//需要将匿名函数用()包裹
(function(){console.log("匿名函数正确执行方式，也叫IIFE")})();//打印。。。
//还有别的写法
+function (){console.log(1)}();//也是
-function (){console.log(2)}();//也是
(function(){console.log(1)}());
```

我们之前讲函数的时候讲到过函数加括号表示立即执行。但是为了不引起歧义需要将函数整体括起来，此时这个函数中形成一个单独的立执行匿名函数作用域，函数名和函数里面的值都不可以访问，可以说整个立执行的区域形成了一个安全区。

比如我们整体将JS代码写成一个立执行函数，那么你的JS代码就是安全的不可修改的。

## 5. 垃圾回收机制

​	JavaScript是具有自动垃圾收集机制的。通常情况下，程序在执行的过程中，会存储各种变量以及环境(作用域)。如果不对不需要的内容定时清理，就会使得页面的内存占用越来越多，使得浏览器越来越卡影响用户体验，所以，需要对不需要的变量或者没有使用的作用域进行定期清理。定时删除不需要无影响的内容。

​	这种清理是自动的，无需手动管理，这是依赖优秀的垃圾回收机制。

* 标记清除( mark-and-sweep)

  JavaScript最常用的是标记清除：当变量进入环境(作用域)，则将变量标记为进入环境，当变量离开环境的时候，将其标记为离开环境。

  垃圾收集器在运行时会给存储在内存种所有变量标记，然后去掉环境变量与被环境变量引用的变量，剩下的就是环境无法访问的变量，这些变量以及其占用的内容空间将被清理回收。

* 引用计数( reference counting)

  不太常见的垃圾回收策略：引用计数。跟踪每一个值得引用次数。当声明一个引用并将一个引用类型赋值给这个变量得时候，这个值得引用计数加1，如果又把这个引用给了第三个变量，那么引用计数又加1，变成2。如果有变量得引用被指向了别的值，那么引用计数减1，直到等于0。意味着这个值已经不会被变量引用，垃圾收集器下次运行得时候就会清理引用为0得值所占据得内存。

  如果一个值得引用出现闭环得话，这个值得引用不会变为0，循环引用使得值得内存永远得不到回收。意味着永远占用内存。

  所以：对于不需要得值，或者使用完得值，请手动将变量得指向指向清除。

  ```js
  var obj = document.getElementById("box");
  obj.style.color = "blue";
  obj = null;//清空指向
  ```

  引用类型将在后面讲到。
